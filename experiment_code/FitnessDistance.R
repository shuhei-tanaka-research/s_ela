selectMin <- function(y, tie.breaker = "first") {
  # Find the minimum value
  min.value <- min(y)
  # Get indices of the minimum value
  idx <- which(y == min.value)
  
  # Handle tie-breaking
  if (length(idx) > 1) {  # If multiple indices exist
    if (tie.breaker == "first") {
      return(idx[1])  # Select the first index
    } else if (tie.breaker == "last") {
      return(idx[length(idx)])  # Select the last index
    } else if (tie.breaker == "sample" || tie.breaker == "random") {
      return(sample(idx, 1))  # Randomly select one index
    } else {
      stop("Invalid tie.breaker value.")  # Raise an error for invalid input
    }
  }
  
  # If only one index exists, return it
  return(idx)
}


FitnessDistanceFeatures = function(X, Y,control = NULL, minimize = TRUE) {
  
  if (is.null(control)) control <- list()
  assertList(control)
  measureTime(expression({
    X = X
    y = Y
    
    if (!minimize)
      y = -1 * y
    opt.x = NULL
    opt.y = NULL
    if (is.null(opt.y)) {
      opt.y = min(y)
    }
    tie.breaker = "sample"
    if (is.null(opt.x)) {
      id.opt = selectMin(y, tie.breaker = tie.breaker)
      opt.x = X[id.opt,]
    }
    prop.best = 1
    assertNumber(prop.best, lower = .Machine$double.eps, upper = 1, null.ok = FALSE)
    
    if (prop.best < 1) {
      n.best = ceiling(length(y[1, ]) * prop.best)
      idx = which(y <= y[order(y)[n.best]])
      if (sum(idx) < 2L) {
        stop(sprintf("Selecting only %.1f%% of the sample results in less than 2 remaining observations.", 100 * prop.best))
      }
      y = y[idx]
      X = X[idx,]
    }
    
    id.opt = selectMin(y, tie.breaker = tie.breaker)
    d.meth = "minkowski"
    d.p = 2L
    dists = dist(X, method = d.meth, p = d.p)
    dists = as.vector(dists)
    
    N = length(y)
    j = seq_len(id.opt - 1L)
    d.rel = c(dists[cumsum(N - j) - (N - id.opt)], 0)
    if (id.opt < N) {
      d.rel = c(d.rel, dists[(sum(N - j) + 1L) : sum(N - seq_len(id.opt))])
    }
    
    fd.cov = stats::cov(y, d.rel)
    fd.cor = fd.cov / (sd(y) * sd(d.rel))
    
    list(fitness_distance.fd.cor = fd.cor,
         fitness_distance.fd.cov = fd.cov,
         fitness_distance.distance.mean = mean(d.rel),
         fitness_distance.distance.sd = sd(d.rel),
         fitness_distance.fitness.mean = mean(y),
         fitness_distance.fitness.sd = sd(y)
    )
  }), "fitness_distance")
}